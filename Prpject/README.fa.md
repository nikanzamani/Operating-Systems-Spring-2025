**پروژه شبیه‌سازی سیستم‌عامل**

---

## 1. معرفی پروژه

**هدف:** طراحی یک شبیه‌ساز متنی برای مفاهیم پایه‌ای سیستم‌عامل در سه فاز:

* **فاز 1:** فقط زمان‌بندی CPU.
* **فاز 2:** فاز 1 + جلوگیری از بن‌بست.
* **فاز 3:** فاز 2 + مدیریت حافظه (صفحه‌بندی).

هر فاز بر اساس فاز قبلی ساخته می‌شود. دانشجویان می‌توانند هر تعداد از فازها را پیاده‌سازی کنند، اما برای نمره کامل باید فاز 3 را انجام دهند. برنامه باید ورودی را از **stdin** بخواند و خروجی را به **stdout** بنویسد.

**جزئیات فازها**

| فاز   | وظایف                                                                                           |
| ----- | ----------------------------------------------------------------------------------------------- |
| فاز 1 | زمان‌بندی پیش‌گیرانه CPU: دستورات `Run` و `Sleep`.                                              |
| فاز 2 | تخصیص/آزادسازی منابع (`Allocate` و `Free`) به همراه جلوگیری از بن‌بست (مثلاً الگوریتم بانکدار). |
| فاز 3 | حافظه مجازی: جدول صفحات، جریمه‌های I/O، و سیاست جایگزینی صفحات (مثل LRU).                       |

---

## 2. تعیین الگوریتم بر اساس شماره دانشجویی

دانشجویان می‌توانند حداکثر در تیم‌های 3 نفره کار کنند. برای تعیین الگوریتم‌های مورد نیاز، مراحل زیر را انجام دهید:

1. **سه رقم آخر** شماره دانشجویی هر عضو را استخراج کنید.
2. مجموع این اعداد را محاسبه کرده و به عنوان عدد `X` در نظر بگیرید. مثلا اگر تیم شامل دانشجویانی با شماره‌های `...999` و `...123` باشد، آنگاه `X = 999 + 123 = 1122` خواهد بود.
3. از عدد `X` برای تعیین الگوریتم‌های مورد استفاده در هر فاز استفاده کنید:

### فاز 1 — الگوریتم زمان‌بندی CPU

```
X mod 4:
0 → FCFS (اولین آماده، اولین اجرا)
1 → SJF  (کوتاه‌ترین شغل اول)
2 → RR   (Round Robin با کوانتوم 5 میلی‌ثانیه)
3 → MLFQ (صف چندسطحی با بازخورد)
       - صف 1: کوانتوم 4 میلی‌ثانیه
       - صف 2: کوانتوم 8 میلی‌ثانیه
       - صف 3: FCFS
```

### فاز 2 — استراتژی مقابله با بن‌بست

```
X mod 2:
0 → الگوریتم بانکدار (پیشگیری از بن‌بست با بررسی حالت ایمن)
1 → تشخیص و بازیابی از بن‌بست
       - استفاده از گراف تخصیص منابع برای تشخیص چرخه‌ها
       - بازپس‌گیری منابع برای بازیابی از بن‌بست
```

### فاز 3 — سیاست جایگزینی صفحه

```
X mod 3:
0 → LRU      (کمترین استفاده اخیر)
1 → Optimum  (بهینه‌ترین با نگاه به آینده)
2 → FIFO     (اولین داخل، اولین خارج)
```

الگوریتم‌های انتخابی باید به‌وضوح در کد و مستندات تیم ذکر شوند.

---

## 3. فرمت ورودی

ورودی به صورت زیر تعریف می‌شود:

```
n                              
m                             
a₀ a₁ a₂ … aₘ₋₁                     
PS PC
IC₀                          
<دستورات فرایند 0>
IC₁       
<دستورات فرایند 1>  
...
ICₘ₋₁
<دستورات فرایند n-1>    
```

1. **خط 1:** `n` — تعداد فرایندها.
2. **خط 2:** `m` — تعداد انواع منابع.
3. **خط 3:** `a₀ a₁ a₂ … aₘ₋₁` — تعداد موجود از هر منبع.

   * اگر `m = 0` و خط سوم برابر `0` باشد، فازهای 2 و 3 حذف می‌شوند.
4. **خط 4:** `PS PC` — اندازه صفحه و تعداد قاب‌ها در حافظه.

   * اگر `PS = PC = 0`، فاز 3 حذف می‌شود.
5. **تعریف فرایندها:** برای هر فرایند `pid` از `0` تا `n-1`:

   1. **خط:** `IC` — تعداد دستورات.
   2. **`IC` خط بعدی:** هر خط یک دستور از فرمت‌های زیر:

      ```
      Run <T>           # استفاده از CPU به مدت T میلی‌ثانیه
      Sleep <T>         # بلاک شدن برای T میلی‌ثانیه
      Allocate <X> <Y>  # درخواست X واحد از منبع نوع Y
      Free <X> <Y>      # آزادسازی X واحد از منبع نوع Y
      Read <A>          # خواندن آدرس منطقی A
      Write <A>         # نوشتن آدرس منطقی A
      ```

---

## 4. فرمت خروجی

ابتدا یک عدد `L` — تعداد رخدادهای تولیدی — را چاپ کنید. سپس `L` خط رخداد با یکی از فرمت‌های زیر:

| کلیدواژه | فرمت                               | توضیح                                          |
| -------- | ---------------------------------- | ---------------------------------------------- |
| EXECUTE  | `EXECUTE <pid> <start> <end>`      | اجرای فرایند از `start` تا `end`.              |
| WAIT     | `WAIT    <pid> <start> <end>`      | بلاک شدن یا خواب بودن از `start` تا `end`.     |
| GIVE     | `GIVE    <pid> <X> <res> <t>`      | آزادسازی X واحد منبع res توسط pid در زمان `t`. |
| TAKE     | `TAKE    <pid> <X> <res> <t>`      | تخصیص X واحد منبع res به pid در زمان `t`.      |
| DTM      | `DTM     <pid> <page> <frame> <t>` | انتقال صفحه از دیسک به حافظه در زمان `t`.      |
| MTD      | `MTD     <pid> <page> <frame> <t>` | انتقال صفحه از حافظه به دیسک در زمان `t`.      |
| RM       | `RM      <pid> <frame> <t>`        | خواندن از حافظه در زمان `t`.                   |
| WM       | `WM      <pid> <frame> <t>`        | نوشتن به حافظه در زمان `t`.                    |

* همۀ اندیس‌ها صفر مبنا هستند (`pid`، منابع، صفحات، قاب‌ها).
* جریمه‌ها:

  * `40ms` برای DTM و MTD
  * `20ms` برای RM و WM


---

## 5. جزئیات رفتاری

### زمان‌بندی CPU (فاز 1)

* در هر لحظه تنها یک فرایند می‌تواند `Run` شود.
* دستور `Sleep <T>` فرایند را دقیقاً برای T میلی‌ثانیه مسدود می‌کند. فرایندهای زیادی می‌توانند همزمان در حالت خواب باشند.
* مثال نمودار زمانی:

(نمودارها و مثال‌ها در بخش بعد آمده است)

### جلوگیری از بن‌بست (فاز 2)

* الگوریتم جلوگیری از بن‌بست اولویت بالاتری نسبت به زمان‌بندی دارد. اگر الگوریتم زمان‌بندی قصد اجرای فرایندی را داشته باشد اما الگوریتم جلوگیری از بن‌بست اجازه ندهد، آن فرایند نباید اجرا شود.
* شما می‌توانید منابع را به طور موقت از فرایندها بگیرید، به شرط آنکه قبل از اجرای بعدی آن فرایند، منابع بازگردانده شوند.

### مدیریت حافظه (فاز 3)

* **مدیریت page fault:**

  1. اگر صفحه در حافظه نیست: `DTM` (خواندن از دیسک).
  2. اگر صفحه‌ای که باید اخراج شود dirty باشد: `MTD` (نوشتن به دیسک).
* برای هر دستور `Read` باید یک `RM` در خروجی داشته باشید.
* برای هر دستور `Write` باید یک `WM` در خروجی داشته باشید.
* دستورات حافظه (خواندن/نوشتن) مسدودکننده هستند؛ به صورت هم‌زمان نمی‌توان به حافظه دسترسی داشت.
* شما می‌توانید منابع را به صورت موقت از فرایند بگیرید، مشروط بر اینکه قبل از اجرای بعدی آن‌ها را بازگردانید.

---

## 6. مثال‌ها

### Phase 1   
**Input**:  
```  
3  
0  
0  
0 0    
3  
Run 2  
Sleep 5
Run 3  
3  
Run 2  
Sleep 7
Run 2  
3  
Run 2  
Sleep 6
Run 3  
```  
**Output**:  
```  
9  
EXECUTE 0 0 2  
WAIT 0 2 7
EXECUTE 1 2 4  
WAIT 1 4 11
EXECUTE 2 4 6  
WAIT 2 6 12
EXECUTE 0 7 10  
EXECUTE 1 11 13  
EXECUTE 2 13 16  
```  

**Timeline:**

```
Time → 0  1  2  3  4  5  6  7  8  9  10  11  12  13  14  15 16
P0     |==E==||======W======||===E===|
P1           |==E==||=========W==========||===E===|
P2                 |==E==||=========W========|    |===E===|
```

### Phase 2  
#### Example 1:
**Input**:  
```  
2  
1  
1  
0 0  
2  
Allocate 1 0  
Run 1  
2  
Allocate 1 0  
Run 1  
```  
**Output**:  
```  
5  
GIVE 0 1 0 0  
EXECUTE 0 0 1  
TAKE 0 1 0 1
GIVE 1 1 0 1  
EXECUTE 1 1 2   
```  


#### Example 2:
**Input**:  
```  
2  
2  
1 1  
0 0  
5  
Allocate 1 0  
Run 1
Sleep 2  
Allocate 1 1  
Run 1  
5  
Allocate 1 1  
Run 1  
Sleep 4
Allocate 1 0  
Run 1  
```  
**Output**:  
```  
14  
GIVE 0 1 0 0  
EXECUTE 0 0 1  
WAIT 0 1 3
GIVE 1 1 1 1  
EXECUTE 1 1 2   
WAIT 0 2 6
TAKE 1 1 1 3
GIVE 0 1 1 3  
EXECUTE 0 3 4  
TAKE 0 1 0 6
TAKE 0 1 1 6
GIVE 0 1 0 6  
GIVE 0 1 1 6  
EXECUTE 1 6 7  
```  


### Phase 3   
**Input**:  
```  
1  
1  
1  
100 1  
9  
Read 250
Run 5
Write 240
Read 50
Run 7
Read 30
Run 3
Read 150
Run 10

```  
**Output**:  
```  
13  
DTM 0 2 0 0  
RM 0 0 40     
EXECUTE 0 60 65
WM 0 0 65
MTD 0 2 0 85
DTM 0 0 0 125
RM 0 0 165
EXECUTE 0 185 192
RM 0 0 192
EXECUTE 0 212 215
DTM 0 1 0 215
RM 0 0 255
EXECUTE 0 275 285
```  
* اندازهٔ هر صفحه ۱۰۰ است، بنابراین آدرس‌های منطقی ۰ تا ۹۹ روی صفحهٔ ۰ قرار دارند، آدرس‌های ۱۰۰ تا ۱۹۹ روی صفحهٔ ۱، و به همین ترتیب ادامه پیدا می‌کند.
* به ۴ خواندن زیر دقت کنید:

  * اولین خواندن باعث page fault می‌شود و در نتیجه یک `DTM` و یک `RM` اتفاق می‌افتد.
  * سپس روی همان صفحه نوشتن انجام می‌شود، بنابراین دومین `Read` باعث یک `WM` و یک `MTD` می‌شود.
  * سومین `Read` مربوط به همان صفحهٔ دوم است، پس نیازی به `DTM` نیست.
  * مورد آخر نشان می‌دهد که اگر صفحه‌ای تغییر نکرده باشد، نیازی به نوشتن دوبارهٔ آن نیست.


---

## 7. تحویل و نمره‌دهی

* **زبان برنامه‌نویسی:** آزاد؛ فقط باید ورودی را از **stdin** بخواند و خروجی را به **stdout** بنویسد، دقیقاً مطابق فرمت تعریف‌شده.
* **تست:** آزمون خودکار با مجموعه تست‌های مخفی که شرایط خاص و لبه‌ای (مثل همزمانی خواب‌ها، درخواست‌های حداکثری منابع، ازدحام حافظه) را پوشش می‌دهد.
* **معیار نمره‌دهی:**

  1. **درستی:** رخدادها با زمان‌بندی و محدودیت‌های تعریف‌شده مطابقت داشته باشند.
  2. **فرمت:** ساختار ورودی/خروجی به‌طور دقیق رعایت شده باشد.
  3. **کیفیت کد:** سازمان‌دهی مناسب و توضیحات واضح برای منطق زمان‌بندی، تخصیص منابع، و مدیریت حافظه.

---
